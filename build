#!/usr/bin/env ruby

# frozen_string_literal: true

require 'fileutils'
require 'time'

BUNDLE_FILE = 'bundle.txt'
BUILD_DIR = 'builds'

# TIC-80 Supported Languages Configuration
# https://github.com/nesbox/TIC-80/wiki/supported-languages
LANG_CONFIG = {
  '.lua' => { name: 'lua', comment_char: '--' },
  '.moon' => { name: 'moon', comment_char: '--' },
  '.js' => { name: 'js', comment_char: '//' },
  '.rb' => { name: 'ruby', comment_char: '#' },
  '.wren' => { name: 'wren', comment_char: '//' },
  '.fnl' => { name: 'fennel', comment_char: ';;' },
  '.nut' => { name: 'squirrel', comment_char: '//' },
  '.janet' => { name: 'janet', comment_char: '#' },
  '.py' => { name: 'python', comment_char: '#' }
}.freeze

HEADER_BASE_KEYS = %w[title author desc site license version].freeze
INCLUDE_REGEX = /^\s*#include\s+(.*)\s*$/.freeze
ASSET_REGEX_STR = '<[A-Z]+>'
BUNDLE_START_MARKER_BASE = '--- BEGIN BUNDLED CODE ---'
BUNDLE_END_MARKER_BASE   = '--- END BUNDLED CODE ---'

# --- HELPERS ---
def error_exit(message)
  puts "üí• \e[31mError: #{message}\e[0m"
  exit 1
end

def success_exit(message)
  puts "‚úÖ \e[32m#{message}\e[0m"
  exit 0
end

# --- VALIDATION ---
def validate_master_file(path, lines, lang_config)
  puts "üîé Validating master file: #{path} (as #{lang_config[:name]})"
  error_exit('Master file must have at least 7 lines for the header.') if lines.count < 7

  comment_char = lang_config[:comment_char]
  header_keys = HEADER_BASE_KEYS.map { "#{comment_char} #{_1}:" }

  header_keys.each_with_index do |key, i|
    error_exit("Invalid header. Line #{i + 1} should start with '#{key}'.") unless lines[i].strip.start_with?(key)
  end

  script_tag = "#{comment_char} script:  #{lang_config[:name]}"
  error_exit("Invalid header. Line 7 should be '#{script_tag}'.") unless lines[6].strip == script_tag
  puts '   - Header is valid.'
end

def parse_bundle_file
  unless File.exist?(BUNDLE_FILE)
    puts "‚ú® '#{BUNDLE_FILE}' not found. Creating a template for you..."
    template_content = <<~TEMPLATE
      # This file lists all the source files to be included in the final build.
      # The build script respects the order of inclusion, so make sure to
      # list files with dependencies before the files that use them.

      # Add your files here using the #include directive. For example:
      #
      # #include src/utils.lua
      # #include src/player.lua
      # #include src/main.lua
    TEMPLATE
    File.write(BUNDLE_FILE, template_content)
    success_exit("'#{BUNDLE_FILE}' created. Please add your source files to it and run the build again.")
  end

  puts "üîé Parsing '#{BUNDLE_FILE}'..."

  included_files = File.readlines(BUNDLE_FILE).map do |line|
    match = line.match(INCLUDE_REGEX)
    if match
      path = match[1].strip
      # Handle both quoted and unquoted paths
      if (path.start_with?('"') && path.end_with?('"')) || (path.start_with?("'") && path.end_with?("'"))
        path[1..-2]
      else
        path
      end
    else
      nil
    end
  end.compact

  error_exit("'#{BUNDLE_FILE}' contains no valid #include statements.") if included_files.empty?

  duplicates = included_files.select { included_files.count(_1) > 1 }.uniq
  error_exit("Duplicate entries found in '#{BUNDLE_FILE}': #{duplicates.join(', ')}") unless duplicates.empty?

  included_files.each do |file|
    error_exit("Included file not found: #{file}") unless File.exist?(file)
  end

  puts "   - Found #{included_files.count} files to include."
  included_files
end

# --- MAIN LOGIC ---
# 1. Check arguments and determine language
master_file_path = ARGV.first
error_exit("Usage: ./bin/build <master_file_path>") unless master_file_path
error_exit("Master file not found: #{master_file_path}") unless File.exist?(master_file_path)

file_ext = File.extname(master_file_path)
lang_config = LANG_CONFIG[file_ext]
error_exit("Unsupported file type: '#{file_ext}'. Supported types are: #{LANG_CONFIG.keys.join(', ')}") unless lang_config

# 2. Read and validate master file
master_lines = File.readlines(master_file_path)
validate_master_file(master_file_path, master_lines, lang_config)

# 3. Clean previous build artifacts from master_lines
puts 'üßπ Cleaning previous build artifacts...'
comment_char = lang_config[:comment_char]
start_marker_line = "#{comment_char} #{BUNDLE_START_MARKER_BASE}"
end_marker_line = "#{comment_char} #{BUNDLE_END_MARKER_BASE}"

start_index = master_lines.index { _1.strip == start_marker_line }
end_index = master_lines.index { _1.strip == end_marker_line }

if start_index && end_index
  master_lines.slice!(start_index..end_index)
  puts '   - Found and removed existing bundled code block.'
else
  puts '   - No previous build artifacts found.'
end

# 4. Parse bundle.txt
included_files = parse_bundle_file

# 5. Separate master file sections from the (potentially cleaned) lines
puts 'üî™ Slicing master file into sections...'
asset_regex = /^#{comment_char} #{ASSET_REGEX_STR}/
asset_start_index = master_lines.index { _1.match?(asset_regex) }
error_exit("No asset section (e.g., # <TILES>) found in master file.") unless asset_start_index

header_section = master_lines[0..6].join
master_code_section = master_lines[7...asset_start_index].join
assets_section = master_lines[asset_start_index..-1].join
puts '   - Sections separated successfully.'

# 6. Concatenate included files
puts 'üì¶ Concatenating included files...'
concatenated_code = included_files.map do |file|
  "\n#{comment_char} --- #{file} ---\n" + File.read(file)
end.join

# 7. Assemble final content
puts 'üèóÔ∏è Assembling final content...'

bundle_block = [
  "#{comment_char} #{BUNDLE_START_MARKER_BASE}",
  concatenated_code,
  "#{comment_char} #{BUNDLE_END_MARKER_BASE}"
].join("\n")

final_content = [
  header_section.strip,
  bundle_block,
  master_code_section.strip,
  assets_section.strip
].join("\n\n") + "\n"

# 8. Write output file
puts 'üìù Writing final build file...'
FileUtils.mkdir_p(BUILD_DIR)
timestamp = Time.now.strftime('%Y-%m-%d-%H%M%S')
master_basename = File.basename(master_file_path, '.*')
output_path = File.join(BUILD_DIR, "#{master_basename}-#{timestamp}#{file_ext}")

File.write(output_path, final_content)

success_exit("Build successful! Output at: #{output_path}")
